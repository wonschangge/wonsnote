Linux下使用三方库的所有方式
==========================

途径：

1. 源码合并编译
2. 静态库引用编译
3. 动态库隐性引用编译（包含动态库头文件）
4. 动态库显性引用编译（不包含动态库头文件，dlfcn.h(dlopen/dlsym)）

1和2本质一样，合并.o编成文件，区别为.a是黑盒子，略微安全一些。

3和4的区别：

* 隐形调用方式，在程序执行前，会在系统的指定目录中（如/usr/lib）检查关联的动态库，检测不到会报错。
* 隐形调用方式，在程序执行后，会把关联的动态库都读取到内存中，而不会考虑其当前是否需要。
* 显性调用方式，在dlopen函数执行时，才会在对应目录检查动态库，插件形式的设计。
* 显性调用方式，在dlopen函数执行后，才将动态库拷贝到内存中。

可搭配 https://github.com/wonschangge/dlopen_load_symbol 代码测试来验证内存占用，如：

::

    ps -ef | rg runme
    pmap -x [runme pid]

期间有一个关于编译器智能编译的有趣发现：:doc:`/嵌入式/Linux/智能的编译器`。

.. note:: 在运行内存上，虽然显性引用不包含目标动态库，但如果dlopen动态库的数量较小或体积较小，在缩减运行内存上没有帮助，因本身的libdl库也要占用空间。