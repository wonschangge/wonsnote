智能的编译器
=================

遇到空的死循环将不会继续向下编译
-----------------------------------

偶然间发现，如：

::

    #include <stdio.h>
    #include "sum.h"

    int main() {
        while(1){}

        int a = add(2, 3);
        printf("%d\n", a);
        int b = minus(2, 3);
        printf("%d\n", b);
    }

以上，测试用的外部动态库的函数将不会被检查是否有进行链接，可直接编完。

回想一下，编译器识别到了“空的无意义的死循环”，因此没有继续向下编译。

继续探索一下，这个特性的妙用：

* 在某些场景下的临时debug或功能调试会有作用。
* 临时的欺骗性

有机会深究编译器的优化细节，亦可对主动调试程序有大的帮助。
